---
file: shift10
title: Off the Backburner
date: 5/20/20
excerpt: 
---
I've run out of new things to implement until my partner stirs up a new level design, so I've decided to take care of the glaring "to do" comments in my code concerning collision and camera control. Since I switched to rotating raycasts for collision, testing if the player is grounded and also within a "Tile" game object is now a much more complex task. To make sure the same process could be accomplished, I decided to flesh out the use of the list I created very early on within the CollisionManager, in which I intended to store any objects the player is currently colliding with. This way, I can easily test if the player is grounded by looking for an object that satisfies a certain name or property, which can also be used to center the camera on each tile the player enters. Weirdly, the first solution that came to mind was to use more lists that were separate for each raycast, as it seems to be the most efficient method that still works alongside detecting what side of the player an object is colliding with. Within each method that draws the raycasts, whenever the raycast returns any game object, I add it to one of the respective lists, and then whenever any raycast has stopped returning something, I loop through each separate list, removing any congruent objects from the current collisions list. Tecnically, this doesn't update 100% accurately, but since the player is always rotating, it's definitely a great approximation.

After I got settled with that, I decided to fix some other lurking bugs surrounding the camera, which essentially boiled down to fixing the sequence and applying "else" logic while modifying the camera's culling mask. The non-existent scalability of the rotating raycasts also urked me, so I decided to actually figure out the trigonometry that I briefly tested and sorted out how to relate it to the scale of the object. It turned out that the sine and cosine waves division by 2 was necessary in order to split my 1 by 1 sized object into a sine or cosine wave sized half, and that half needed to be scaled up or down by having the objects vertical or horizontal scale being another divisor under 2. In case I run into more problems (I will), I decided to start work on a separate class that makes logging error messages much quicker and accurate to go about. Hopefully it will be useful for whatever I work on next.