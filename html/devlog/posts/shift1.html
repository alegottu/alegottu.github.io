<!DOCTYPE html>
<html>
    <head>
        <meta charset = "utf-8">
		<meta name="viewport" content="width=device-width">
		<title>Devlogs | Shifting Gears</title>
		<link rel="stylesheet" href="../../../css/posts.css">
    </head>

    <body>
        <header>
            <h1>Shifting Gears</h1>
            <h2>4/24/20</h2>
            <p></p>
        </header>

        <article id="main">
            <p>With all the extra time I have, I've decided to start documenting my progress on my most recent project and also beginning the process of documenting my finished or dropped projects along the way, clearly identifying the reasoning behind the course of the projects, especially the ones that have been "put aside." I've progressed to a certain level of confidence about my latest project to be able to present it, even with simple placeholder sprites, because its the first time I have ever felt actual steady iterative progress without facing an overwhelming mess of bugs pretty early on. Often times I get too excited developing new mechanics that I leave behind glaring messes in fundamental classes of the code, such as in the movement system, and beyond a certain point it had become too daunting to attempt to go back and fix anything. Whether or not I might return to put those fragments of chaos into order one day, I am happy to say that I have achieved the fundamentals quite smoothly for my partner and I's game, "Shift," and I've had fun while doing it. While the name is certainly a work in progress, my partner and I concepted the game for quite awhile, deciding that we wanted a puzzle game that centered around a simple core mechanic which also included platforming. What we came up with was the idea for the levels to modular and tile-based, in which the player can only see one tile at a time, completing miniature puzzles as he goes; the larger puzzle, however, is how to sort the entire level in order to complete it. In line with this, we decided that the player's primary mechanic would be to interact with "workstations" to make a map of the level at certain points in order to see functions of certain portions of the entire level.</p>
<p>So far I have managed to implement a versatile and debugging friendly game manager, complete player movement and collision which fully utilizes object oriented programming and my implementation of a game manager, and a few core mechanics that will serve the player throughout the game. Out of the bunch, despite largely following a tutorial, creating the game manager was particularly satisfying to finally learn how to consider the debugging process through a fundamental function of a game itself. I had worked on player movement before this step and improved upon my use of inheritance and objects by separating complicated player processes such as the jump and collisions into separate classes. As for collision, I made an entirely separate object for it as well, having other objects grab the current instance of it, if needed, so that problems with instantiating and referencing a prefab wouldn't arise. Part of the satisfaction from the generally copied game manager I mentioned earlier was because of utilizations like this.</p>
<p>Not only was I able to fully understand the concepts used in the tutorial more by using it in my unique game, but I was able to make certain improvisations to it to fit for the scaling of my game, and I also utilized the Singleton pattern class for the previously mentioned collision manager that was essential to implementing the game manager, as their would only be one instance of them throughout the duration of a playthrough. As for the players movement, I took an absurd amount of time just to develop a jump that would be both versatile to edit but also felt "floaty" and "weighty" enough for the time being. I discussed this with my partner, Alec (who will mainly be completing graphics for the game once my prototype is done), and he mainly agreed that the above combination fit the logical feel necessary for a puzzle game that places an emphasis or retrospection, but also adhered to the platforming that we desired. As for everything else, I've been back and forth developing the camera and core mechanics of the game bit by bit. The camera needs to show only one tile at a time, so I mainly achieved this through layers and with the use of the Collision class, as well as changing the culling mask of the camera based on certain logic. Then, when the player uses their ability to look back on what tiles they have used comprehensively, the same culling mask scheme is used to show a larger portion of the level as a bigger picture. At first I thought I would use a giant raycast box to change the layer of a portion of things in the scene, but I was absolutely elated to not have to deal with that mess of for loops and if statements when I found the culling mask solution. I'm happy with my progress on the game so far, and I hope I can present a prototype soon, as I have begun work on the first level already.</p>
        </article>
    </body>
</html>